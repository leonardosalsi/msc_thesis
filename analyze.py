import math
import os
import json

import numpy as np
from matplotlib import pyplot as plt

data_location = "./data"

model_aliases = {
    'nucleotide-transformer-v2-50m-multi-species-with-random-weights': 'NT-MS. with rand. weights (50M)',
    'nucleotide-transformer-v2-500m-multi-species-with-random-weights': 'NT-MS. with rand. weights (500M)',
    'nucleotide-transformer-v2-100m-multi-species': 'NT-MS V2 (100M)',
    'nucleotide-transformer-v2-50m-multi-species': 'NT-MS V2 (50M)',
    'nucleotide-transformer-v2-250m-multi-species': 'NT-MS V2 (250M)',
    'nucleotide-transformer-500m-1000g': 'NT-1000g (500M)',
    'nucleotide-transformer-500m-human-ref': 'NT-Human-Ref. (500M)',
    'nucleotide-transformer-v2-500m-multi-species': 'NT-MS V2 (500M)',
}

task_aliases = {
    'H2AFZ': 'H2AFZ',
    'H3K27ac': 'H3K27ac',
    'H3K27me3': 'H3K27me3',
    'H3K36me3': 'H3K36me3',
    'H3K4me1': 'H3K4me1',
    'H3K4me2': 'H3K4me2',
    'H3K4me3': 'H3K4me3',
    'H3K9ac': 'H3K9ac',
    'H3K9me3': 'H3K9me3',
    'H4K20me1': 'H4K20me1',
    'enhancers': 'Enhancers',
    'enhancers_types': 'Enhancers (types)',
    'promoter_all': 'Promoter (all)',
    'promoter_no_tata': 'Promoter (non-TATA)',
    'promoter_tata': 'Promoter (TATA)',
    'splice_sites_all': 'Splice Sites (all)',
    'splice_sites_acceptors': 'Splice Sites (acceptors)',
    'splice_sites_donors': 'Splice Sites (donors)',
    'Genomic_Benchmarks_human_nontata_promoters': 'Promoter Human (no TATA)',
    'Genomic_Benchmarks_human_ensembl_regulatory': 'Human Ensemble (regulatory)',
    'Genomic_Benchmarks_demo_human_or_worm': 'Human or Worm',
    'Genomic_Benchmarks_human_ocr_ensembl': 'Human Ensemble (ocr)',
    'Genomic_Benchmarks_drosophila_enhancers_stark': 'Enhancers (drosophila)',
    'Genomic_Benchmarks_dummy_mouse_enhancers_ensembl': 'Enhancers (mouse)',
    'Genomic_Benchmarks_demo_coding_vs_intergenomic_seqs': 'Coding vs Intergenomic Seq.',
    'Genomic_Benchmarks_human_enhancers_ensembl': 'Enhancers (human ensemble)',
    'Genomic_Benchmarks_human_enhancers_cohn': 'Enhancers (human cohn)',
}

"""
Validate data generated by mcc.py
"""
def validate_data():
    tasks = list(task_aliases.keys())
    for filename in os.listdir(data_location):
        file_path = os.path.join(data_location, filename)
        if os.path.isfile(file_path):
            with open(file_path, 'r') as file:
                content = file.read()
                content = json.loads(content)
                keys = list(content.keys())
                tasks.sort()
                keys.sort()
                for i in range(0, len(tasks)):
                    if (tasks[i] != keys[i]):
                        return False
    return True

"""
Collect and sort data per downstream task
"""
def prepare_data_for_visualization():
    _data = {}
    tasks = list(task_aliases.keys())
    for task in tasks:
        _data[task] = {}
    for filename in os.listdir(data_location):
        model_name = filename.split('.')[0]
        file_path = os.path.join(data_location, filename)
        if os.path.isfile(file_path):
            with open(file_path, 'r') as file:
                content = file.read()
                content = json.loads(content)
                for model_task in content:
                    _data[model_task][model_aliases.get(model_name)] = {'mean': content[model_task]['mean'], 'std': content[model_task]['std']}
    for task in tasks:
        _data[task_aliases.get(task)] = _data.pop(task)


    """Sort each task and model according to task_aliases and model_aliases"""
    tasks_order = {v: i for i, v in enumerate(task_aliases.values())}
    models_order = {v: i for i, v in enumerate(model_aliases.values())}
    sorted_data = {
        outer_key: dict(sorted(inner_dict.items(), key=lambda item: models_order.get(item[0], float('inf'))))
        for outer_key, inner_dict in _data.items()
    }
    sorted_data = dict(sorted(sorted_data.items(), key=lambda item: tasks_order.get(item[0], float('inf'))))
    return sorted_data

def visualize_mcc_per_task(data):
    num_tasks = len(data)
    print(f"Number of tasks: {num_tasks}")
    cols = 3
    rows = math.ceil(num_tasks / cols)

    fig, axes = plt.subplots(rows, cols, figsize=(18, rows * 5), constrained_layout=True)
    axes = axes.flatten()

    colors = plt.cm.tab10.colors

    for idx, (task_name, model_results) in enumerate(data.items()):
        if idx >= len(axes):  # Safety check
            break

        ax = axes[idx]
        model_names = list(model_results.keys())
        mcc_values = [model_results[model]['mean'] for model in model_names]
        std_values = [model_results[model]['std'] * 2 for model in model_names]

        x = np.arange(len(model_names))
        bars = ax.bar(
            x,
            mcc_values,
            yerr=std_values,
            color=colors[:len(model_names)],
            width=0.9,
            capsize=5,
            error_kw={'elinewidth': 2}
        )

        for bar, value in zip(bars, mcc_values):
            if value > 0.2:
                ax.text(
                    bar.get_x() + bar.get_width() / 2,
                    bar.get_y() + 0.05,
                    f"{value:.2f}",
                    ha="center",
                    va="bottom",
                    rotation=90,
                    fontsize=12,
                    color="white",
                    weight="bold",
                )
            else:
                ax.text(
                    bar.get_x() + bar.get_width() / 2,
                    bar.get_y() + bar.get_height() + 0.05,
                    f"{value:.2f}",
                    ha="center",
                    va="bottom",
                    rotation=90,
                    fontsize=12,
                    color="black",
                    weight="bold",
                )

        ax.set_title(task_name, fontsize=24, pad=10, loc="center")
        ax.set_ylim(0, 1)

        col = idx % cols
        is_last_row = idx >= (rows - 1) * cols or idx + cols >= num_tasks
        if is_last_row:
            ax.set_xticks(x)
            ax.set_xticklabels(model_names, rotation=90, ha="center", fontsize=16)
        else:
            ax.set_xticks([])

    for idx in range(num_tasks, len(axes)):
        fig.delaxes(axes[idx])


    plt.show()

def visualize_mcc_across_tasks(data):
    model_mcc = {}
    for (task_name, model_results) in data.items():
        for (model_name, scores) in model_results.items():
            if model_name not in model_mcc:
                model_mcc[model_name] = []
            model_mcc[model_name].append(scores['mean'])


    for (model_name, scores) in model_mcc.items():
        model_mcc[model_name] = np.mean(scores)

    model_names = list(model_mcc.keys())
    mean_mcc = [model_mcc[model] for model in model_names]

    colors = plt.cm.tab10.colors
    fig, ax = plt.subplots(figsize=(6, 6), constrained_layout=True)
    bars = ax.bar(model_names, mean_mcc, color=colors[:len(model_names)], width=0.9)
    for bar, value in zip(bars, mean_mcc):
        if value > 0.2:
            ax.text(
                bar.get_x() + bar.get_width() / 2,
                bar.get_y() + 0.05,
                f"{value:.2f}",
                ha="center",
                va="bottom",
                rotation=90,
                fontsize=12,
                color="white",
                weight="bold",
            )
        else:
            ax.text(
                bar.get_x() + bar.get_width() / 2,
                bar.get_y() + bar.get_height() + 0.05,
                f"{value:.2f}",
                ha="center",
                va="bottom",
                rotation=90,
                fontsize=12,
                color="black",
                weight="bold",
            )
    x = np.arange(len(model_names))
    ax.set_xticks(x)
    ax.set_xticklabels(model_names, rotation=90, ha="center", fontsize=12)
    ax.set_title("Mean MCC across Tasks", fontsize=18, pad=10, loc="center")
    ax.set_ylim(0, 1)
    plt.show()

def visualize_normalized_mcc_across_tasks(data):
    model_mcc = {}
    for (task_name, model_results) in data.items():
        for (model_name, scores) in model_results.items():
            if model_name not in model_mcc:
                model_mcc[model_name] = []
            model_mcc[model_name].append(scores['mean'])

    for (model_name, scores) in model_mcc.items():
        min = np.min(scores)
        max = np.max(scores)
        normalized_scores = (scores - min) / (max - min)
        model_mcc[model_name] = np.mean(normalized_scores)

    model_names = list(model_mcc.keys())
    mean_mcc = [model_mcc[model] for model in model_names]

    colors = plt.cm.tab10.colors
    fig, ax = plt.subplots(figsize=(6, 6), constrained_layout=True)
    bars = ax.bar(model_names, mean_mcc, color=colors[:len(model_names)], width=0.9)
    for bar, value in zip(bars, mean_mcc):
        if value > 0.2:
            ax.text(
                bar.get_x() + bar.get_width() / 2,
                bar.get_y() + 0.05,
                f"{value:.2f}",
                ha="center",
                va="bottom",
                rotation=90,
                fontsize=12,
                color="white",
                weight="bold",
            )
        else:
            ax.text(
                bar.get_x() + bar.get_width() / 2,
                bar.get_y() + bar.get_height() + 0.05,
                f"{value:.2f}",
                ha="center",
                va="bottom",
                rotation=90,
                fontsize=12,
                color="black",
                weight="bold",
            )
    x = np.arange(len(model_names))
    ax.set_xticks(x)
    ax.set_xticklabels(model_names, rotation=90, ha="center", fontsize=12)
    ax.set_title("Normalized mean MCC across Tasks", fontsize=18, pad=10, loc="center")
    ax.set_ylim(0, 1)
    plt.show()

if __name__ == "__main__":
    if not validate_data():
        print('Data validation failed.')
    data = prepare_data_for_visualization()
    with open('mcc_data.json', 'w') as f:
        json.dump(data, f, indent=4)
    visualize_mcc_per_task(data)
    visualize_mcc_across_tasks(data)
    visualize_normalized_mcc_across_tasks(data)